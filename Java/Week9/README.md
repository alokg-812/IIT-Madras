## Week 9

### Layman's Terms Explanation

Imagine you order a meal and you're waiting for the dessert. The waiter gives you a **box** (the `Optional` object).

1.  **The Box Has a Dessert:** The value is **present**. You can open the box and enjoy the dessert (`T`).
2.  **The Box is Empty:** The value is **absent**. Instead of getting food poisoning by accidentally biting into empty air (a `NullPointerException`), you immediately know the dessert is missing.

The key benefit is that because you got a box, you are **forced** to check what's inside before trying to eat. You can decide:

  * **If it's empty,** I'll have a piece of cake instead (`orElse`).
  * **If it's empty,** I'll call the chef and ask them to make a new one (`orElseGet`).
  * **If it's empty,** I'll throw a fit and demand an explanation (`orElseThrow`).

It's a way to clearly communicate "This result *might* be empty, so handle the 'empty' case now."

### 2\. Technical Explanation ‚öôÔ∏è

The core concept covered is the **`Optional<T>` object** in Java, primarily in the context of **Streams** and handling potentially missing results.

#### 2.1. Dealing with Empty Streams

Methods like `max()` and `min()` on a Java Stream return an `Optional<T>` because if the stream is **empty** (or if no elements satisfy a filter), the maximum or minimum value is **undefined**.

  * **Problem:** The return value could be `T` (e.g., `Double`) or `null`. A simple `T` return type would mean returning `null` when no value is found, which leads to `NullPointerException` later.
  * **Solution:** By returning **`Optional<T>`**, the result clearly signals that the value *might* not be there.

**Example from slides:**

```java
Optional<Double> maxrand =
    Stream.generate(Math::random) // Start generating random doubles
          .limit(100)           // Take 100 of them
          .filter(n -> n < 0.001) // Keep only very small numbers
          .max(Double::compareTo); // Find the largest one
// maxrand is Optional<Double> because the filter might result in an empty stream.
```

#### 2.2. Handling Missing Optional Values

The `Optional` class provides several methods to safely extract the value or provide an alternative:

| Method | Description | Code Example |
| :--- | :--- | :--- |
| **`orElse(T other)`** | Returns the contained value if present; otherwise, returns the **default value** provided. | `Double fixrand = maxrand.orElse(-1.0);` |
| **`orElseGet(Supplier<? extends T> supplier)`** | Returns the value if present; otherwise, returns the value **generated by the supplied function**. | `Double fixrand = maxrand.orElseGet(() -> someFunctionToGenerateDouble());` |
| **`orElseThrow(Supplier<? extends X> exceptionSupplier)`** | Returns the value if present; otherwise, **throws the exception** generated by the supplied function. | `Double fixrand = maxrand.orElseThrow(IllegalStateException::new);` |
| **`ifPresent(Consumer<? super T> action)`** | If a value is present, executes the given action on the value. If not present, **nothing happens**. | `maxrand.ifPresent(v -> results.add(v));` |
| **`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`** | If a value is present, performs the action; otherwise, performs the **`emptyAction`**. | `maxrand.ifPresentOrElse(v -> results.add(v), () -> System.out.println("No max"));` |

#### 2.3. Creating an Optional Value

You can manually create `Optional` objects:

  * **`Optional.of(v)`:** Creates an `Optional` containing the non-null value `v`. (Throws `NullPointerException` if `v` is null).
  * **`Optional.empty()`:** Creates an empty `Optional`.
  * **`Optional.ofNullable(v)`:** Creates an `Optional` containing `v` if it is non-null, or an empty `Optional` if `v` is `null`. **(Highly useful when dealing with old code that returns `T` or `null`)**.

**Example using `ofNullable`:**

```java
public static Optional<Double> inverse(Double x) {
    // If x is 0, (1/x) would lead to an error or NaN.
    // Returning Optional.ofNullable(1/x) would typically be used 
    // for functions that return null, but here it's shown conceptually.
    // A better implementation for inverse:
    if (x == 0) {
        return Optional.empty();
    }
    return Optional.of(1.0 / x);
}
```

#### 2.4. Passing and Transforming Optional Values

  * **`map(Function<? super T, ? extends U> mapper)`:** If the `Optional` is present, it applies the function (`mapper`) to the value and wraps the result in a new `Optional<U>`. If the `Optional` is empty, it returns an empty `Optional<U>`.

```java
// If maxrand is present, it gets squared and wrapped in maxrandsqr.
Optional<Double> maxrandsqr = maxrand.map(v -> v * v); 
```
  * **`or(Supplier<? extends Optional<? extends T>> supplier)`:** If a value is present, it returns that `Optional`. If it is empty, it returns the `Optional` generated by the supplied `supplier`.

```java
// If maxrand is empty, this returns Optional.of(-1.0).
Optional<Double> fixrand = maxrand.or(() -> Optional.of(-1.0));
```

#### 2.5. Composing Functions with `flatMap` ‚õìÔ∏è

When a function takes a value `T` and returns an **`Optional<U>`**, and you want to chain it with an existing `Optional<T>`, you must use **`flatMap`** to avoid nested `Optional` types (e.g., `Optional<Optional<U>>`).

  * **`flatMap(Function<? super T, ? extends Optional<? extends U>> mapper)`:** If the `Optional` is present, it applies the function (`mapper`) which *already* returns an `Optional<U>`. It returns this resulting `Optional<U>`. If the initial `Optional` is empty, it returns an empty `Optional<U>`.

**Example:** Chaining a safe `inverse` function and a safe `squareRoot` function.

```java
public static Optional<Double> inverse(Double x) {
    return (x == 0) ? Optional.empty() : Optional.of(1.0 / x);
}

public static Optional<Double> squareRoot(Double x) {
    return (x < 0) ? Optional.empty() : Optional.of(Math.sqrt(x));
}

// Chain the operations: 
// 1. Get inverse of x (returns Optional<Double>)
// 2. If present, flatMap applies squareRoot to the result
// The final result is Optional<Double>
Optional<Double> result = inverse(x).flatMap(MyClass::squareRoot);
```

#### 2.6. Turning an Optional into a Stream üåä

`Optional<T>` can be converted into a `Stream` containing either **zero** elements (if empty) or **one** element (if present) using `Optional::stream`. This is useful when processing a stream of inputs where a lookup operation might fail.

```java
// Assume Users::lookup returns Optional<User>
Stream<String> ids = Stream.of("user1", "user2", "missingUser");

Stream<User> users = ids.map(Users::lookup) // Stream<Optional<User>>
                        .flatMap(Optional::stream); // Flatten to Stream<User> (dropping empty Optionals)
```

### 3\. Illustrative Java Code Examples üíª

Here is a consolidated example demonstrating the key concepts:

```java
import java.util.Optional;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;

public class OptionalDemo {

    // Helper function that might return a User or null (old style)
    public static String oldLookup(String id) {
        if (id.equals("admin")) {
            return "Admin User Data"; // Present
        }
        return null; // Missing
    }

    public static void main(String[] args) {
        Random rand = new Random();
        
        // --- 1. Creating an Optional and Dealing with Nulls ---
        System.out.println("--- 1. Creating and Handling Nulls ---");
        
        // Use ofNullable to safely handle a potential null return
        Optional<String> maybeUser = Optional.ofNullable(oldLookup("guest"));
        
        // Handling the missing value with orElse
        String userData = maybeUser.orElse("Default Guest");
        System.out.println("User Data (orElse): " + userData); // Output: Default Guest

        // Handling the present value with ifPresent
        Optional<String> adminUser = Optional.ofNullable(oldLookup("admin"));
        adminUser.ifPresent(data -> System.out.println("Admin Present: " + data)); 
        
        // --- 2. Transforming Optional Values (map) ---
        System.out.println("\n--- 2. Transforming (map) ---");
        
        // Start with a present value
        Optional<Integer> number = Optional.of(10);
        
        // Map: Double the value if present (result is Optional<Integer>(20))
        Optional<Integer> doubled = number.map(n -> n * 2);
        System.out.println("Doubled Value: " + doubled.orElse(0)); // Output: 20

        // Map on an empty Optional (result is still empty)
        Optional<Integer> empty = Optional.empty();
        Optional<Integer> mappedEmpty = empty.map(n -> n * 2);
        System.out.println("Mapped Empty Value: " + mappedEmpty.orElse(0)); // Output: 0
        
        // --- 3. Chaining with flatMap (Concept from slide 21) ---
        System.out.println("\n--- 3. Chaining with flatMap ---");
        
        // Suppose we have an Optional that may or may not be the inverse of a number
        Optional<Double> result = inverse(2.0)
            .flatMap(OptionalDemo::squareRoot); // Applies safe squareRoot to the result of safe inverse
            
        System.out.println("Inverse then SquareRoot of 2.0: " + result.orElse(Double.NaN)); // Output: 0.707...

        Optional<Double> zeroResult = inverse(0.0)
            .flatMap(OptionalDemo::squareRoot);
            
        System.out.println("Inverse then SquareRoot of 0.0: " + zeroResult.orElse(Double.NaN)); // Output: NaN
    }
    
    // Example: Function returning Optional<Double>
    public static Optional<Double> inverse(Double x) {
        return (x == 0) ? Optional.empty() : Optional.of(1.0 / x);
    }

    // Example: Function returning Optional<Double>
    public static Optional<Double> squareRoot(Double x) {
        return (x < 0) ? Optional.empty() : Optional.of(Math.sqrt(x));
    }
}
```

## Lecture 2

### 1\. Layman's Terms Explanation üí°

Imagine a **Stream** is a conveyor belt carrying items (data) through a factory.

1.  **Putting Items on the Belt:** You can start the belt by putting items from a storage bin (a **Collection**) onto it.
2.  **Processing Items:** You can inspect, clean, or modify the items as they pass by (this is the stream processing: `map`, `filter`, etc.).
3.  **Collecting Results:** When the processing is done, you need a way to store the final results, since the conveyor belt eventually ends. The **`collect()`** operation acts like the final packaging station:
      * **Packaging into a Crate (`toList`/`toSet`):** Grouping all items into a single list or set.
      * **Packaging into Labeled Bins (`toMap`):** Storing items based on unique labels (keys), like separating mail by address.
      * **Creating a Report (`summarizingInt`):** Instead of storing the items, you just measure and report the total count, largest size, average weight, etc.
      * **Creating Grouped Crates (`groupingBy`/`partitioningBy`):** Automatically sorting and packaging items into separate crates based on a specific characteristic (e.g., all red items in one box, all blue in another).

-----

### 2\. Technical Explanation ‚öôÔ∏è

The core mechanism for converting a stream back into a collection or summary is the **`collect()`** terminal operation, which works with implementations from the **`java.util.stream.Collectors`** class.

#### 2.1. Basic Stream Consumption

Before using `collect()`, there are simpler ways to consume a stream:

| Method | Description | Code Example |
| :--- | :--- | :--- |
| **Iterator/Loop** | Streams define a standard iterator, allowing explicit looping. | `mystream.iterator();` |
| **`forEach(Consumer)`** | Executes an action for each element in the stream. No result is returned. | `mystream.forEach(System.out::println);` |
| **`toArray()`** | Converts the stream to an array. By default, it returns `Object[]`. | `Object[] result = mystream.toArray();` |
| **`toArray(IntFunction)`** | Converts to a specific array type by passing an array constructor reference. | `String[] result = mystream.toArray(String[]::new);` |

#### 2.2. Storing as a Collection using `collect()`

The `collect(Collector)` method takes a `Collector` object which defines how to accumulate the stream elements into a final result container.

| Collector Method | Resulting Collection Type | Code Example |
| :--- | :--- | :--- |
| **`Collectors.toList()`** | Returns a `List<T>`. | `List<String> result = mystream.collect(Collectors.toList());` |
| **`Collectors.toSet()`** | Returns a `Set<T>`. | `Set<String> result = mystream.collect(Collectors.toSet());` |
| **`Collectors.toCollection(Supplier)`** | Returns a concrete, specific collection type (e.g., `TreeSet`, `ArrayList`) using a constructor reference. | `TreeSet<String> result = stream.collect(Collectors.toCollection(TreeSet::new));` |

#### 2.3. Stream Summaries

The `Collectors` class provides methods to aggregate numerical statistics into a single object (`SummaryStatistics`). This often involves transforming the stream elements into numbers first.

  * **Key Methods:** `summarizingInt()`, `summarizingLong()`, `summarizingDouble()`.
  * **Input:** A function (mapper) to convert the stream element type (`T`) to the required primitive type (e.g., `String::length` converts a `String` to its `int` length).
  * **Output:** An object (`IntSummaryStatistics`, `LongSummaryStatistics`, etc.) that holds: **count, max, min, sum,** and **average**.

**Example:**

```java
// Collect statistics on the lengths of strings in the stream
IntSummaryStatistics summary = mystream.collect(
    Collectors.summarizingInt(String::length) // Using String::length as the mapper
);

// Accessing the statistics
double averageWordLength = summary.getAverage();
long maxWordLength = summary.getMax(); 
```

#### 2.4. Converting to a Map

`Collectors.toMap()` is used to convert a stream of objects into a `Map`, requiring two functions: one for the **key** and one for the **value**.

1.  **Basic `toMap` (Key & Value Mapper):**

<!-- end list -->

```java
// Stream<Person> -> Map<Integer, String>
Map<Integer, String> idToName = people.collect(
    Collectors.toMap(Person::getId, Person::getName) // Key: ID, Value: Name
);
```

2.  **Using `Function.identity()` (Key Mapper & Object as Value):**

<!-- end list -->

```java
// Stream<Person> -> Map<Integer, Person>
Map<Integer, Person> idToPerson = people.collect(
    Collectors.toMap(Person::getId, Function.identity()) // Key: ID, Value: The entire Person object
);
```

3.  **Handling Duplicate Keys:** If the key mapper generates duplicate keys, `IllegalStateException` is thrown. A third argument is needed to resolve the conflict:

<!-- end list -->

```java
// Duplicate names will occur, so we provide a merge function:
Map<String, Integer> nameToID = people.collect(
    Collectors.toMap(
        Person::getName,    // Key mapper
        Person::getId,      // Value mapper
        (existingValue, newValue) -> existingValue // Merge Function: keep the existing value, discard the new one
    )
);
```

#### 2.5. Grouping and Partitioning

These collectors are used when you want to group elements based on a common property.

  * **`Collectors.groupingBy(Function)`:** Groups the stream elements into a `Map<K, List<T>>` where the key `K` is determined by the grouping function, and the value is a `List` of all elements that share that key.

<!-- end list -->

```java
// Group all Person objects by their name
Map<String, List<Person>> nameToPersons = people.collect(
    Collectors.groupingBy(Person::getName) 
);
```

  * **`Collectors.partitioningBy(Predicate)`:** A specialized grouping that uses a boolean condition (`Predicate`). It results in a `Map<Boolean, List<T>>`, essentially splitting the stream into two lists: one where the predicate is **True** and one where it is **False**.

<!-- end list -->

```java
// Partitioning people into those whose name starts with 'A' and the rest
Map<Boolean, List<Person>> aAndOtherPersons = people.collect(
    Collectors.partitioningBy(p -> p.getName().startsWith("A"))
);

List<Person> startingLetterA = aAndOtherPersons.get(true);
```

-----

### 3\. Illustrative Java Code Examples üíª

```java
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.IntSummaryStatistics;
import java.util.TreeSet;
import java.util.function.Function;

// Simple class for demonstration
class Person {
    private final int id;
    private final String name;
    private final int age;

    public Person(int id, String name, int age) {
        this.id = id; this.name = name; this.age = age;
    }
    public int getId() { return id; }
    public String getName() { return name; }
    public int getAge() { return age; }
    public String toString() { return name + " (" + id + ")"; }
}

public class StreamCollectingDemo {
    public static void main(String[] args) {
        Stream<Person> peopleStream = Stream.of(
            new Person(101, "Alice", 30),
            new Person(102, "Bob", 25),
            new Person(103, "Alice", 35), // Duplicate Name
            new Person(104, "Charlie", 25)
        );

        // --- 1. Collecting to Basic Collections (List & Set) ---
        List<Person> peopleList = peopleStream.collect(Collectors.toList());
        System.out.println("1. List Result: " + peopleList);
        
        // Recreate stream for next operation (streams are consumed after one terminal operation)
        peopleStream = Stream.of(new Person(101, "Alice", 30), new Person(102, "Bob", 25), new Person(103, "Alice", 35), new Person(104, "Charlie", 25));

        // --- 2. Collecting to Map with Duplicate Key Handling ---
        // Using name as key, ID as value. 'Alice' is duplicated.
        Map<String, Integer> nameToIDMap = peopleStream.collect(
            Collectors.toMap(
                Person::getName, 
                Person::getId,
                (existing, replacement) -> existing // Merge: If duplicate, keep the existing ID
            )
        );
        System.out.println("2. Map (with merge): " + nameToIDMap);
        
        // --- 3. Summarizing Statistics ---
        Stream<Person> summaryStream = Stream.of(
            new Person(101, "Alice", 30), new Person(102, "Bob", 25), new Person(103, "Alice", 35), new Person(104, "Charlie", 25)
        );
        
        IntSummaryStatistics ageStats = summaryStream.collect(
            Collectors.summarizingInt(Person::getAge) // Using age as the number field
        );
        System.out.println("3. Age Summary - Average: " + ageStats.getAverage() + ", Max: " + ageStats.getMax());

        // --- 4. Grouping and Partitioning ---
        Stream<Person> groupingStream = Stream.of(
            new Person(101, "Alice", 30), new Person(102, "Bob", 25), new Person(103, "Alice", 35), new Person(104, "Charlie", 25)
        );
        
        // Grouping: Group all people by their age
        Map<Integer, List<Person>> peopleByAge = groupingStream.collect(
            Collectors.groupingBy(Person::getAge)
        );
        System.out.println("4a. Grouped By Age (25): " + peopleByAge.get(25)); // [Bob (102), Charlie (104)]

        // Recreate stream
        groupingStream = Stream.of(new Person(101, "Alice", 30), new Person(102, "Bob", 25), new Person(103, "Alice", 35), new Person(104, "Charlie", 25));
        
        // Partitioning: Split people into those named 'Alice' and those who aren't
        Map<Boolean, List<Person>> alicePartition = groupingStream.collect(
            Collectors.partitioningBy(p -> p.getName().equals("Alice"))
        );
        System.out.println("4b. Partition (True/Alice): " + alicePartition.get(true)); 
    }
}
```


## Lecture 3
This lecture covers Java's fundamental approach to handling data transfer‚Äîreading data **into** the program and writing data **out** of it‚Äîusing I/O Streams.

### Layman's Terms Explanation

In Java I/O, a **Stream** is like a hose or a pipe connecting your program to an external resource (like a file, the internet, or memory).

1. **Data is Raw Bytes:** At the most basic level, everything flowing through the pipe is just a sequence of uninterpreted $\mathbf{raw\ bytes}$[cite: 363, 382]. Your program doesn't know if these bytes represent a letter, a number, or part of an image.
2.  **The Stream Pipeline:** To make sense of the raw bytes, you stack different tools (called **Stream Transformers**) onto the pipe in a sequence, creating a **pipeline**[cite: 387, 781].
      * The first tool connects to the **source** (e.g., a file) and handles the raw bytes[cite: 388].
      * The next tool interprets the bytes as **text** (e.g., converting bytes to Unicode characters)[cite: 364, 383].
      * The tool after that might read the characters and group them into **words** or **lines** (like the `Scanner` tool)[cite: 544].

This separation of concerns‚Äîconnecting, interpreting, and formatting‚Äîmakes the system flexible[cite: 790, 798].


### Technical Explanation

Java's I/O system is built around two abstract classes, **`InputStream`** (for reading) and **`OutputStream`** (for writing), which handle the transfer of **raw bytes**[cite: 393, 400]. These are distinct from the `java.util.stream.Stream` class used for collections[cite: 349, 378].

#### 2.1. Reading and Writing Raw Bytes

The basic byte streams are the foundation for I/O[cite: 393].

| Stream Type | Purpose | Abstract Methods (Examples) | Management |
| :--- | :--- | :--- | :--- |
| **`InputStream`** | Reads sequences of raw bytes[cite: 331, 400]. | `read()`, `read(byte[] b)`, `readAllBytes()`, `available()`[cite: 402, 412, 413, 414, 419]. | Must be **closed** to release resources (`in.close()`)[cite: 446, 451]. |
| **`OutputStream`** | Writes sequences of raw bytes[cite: 334, 400]. | `write(int b)`, `write(byte[] b)`[cite: 433, 447]. | Must be **closed** and **flushed** (`out.flush()`) because output is often buffered[cite: 462, 468]. |

#### 2.2. Connecting to External Sources (Files)

Subclasses of `InputStream` and `OutputStream` connect to specific sources like files[cite: 474, 476].

  * **File Input:** `var in = new FileInputStream("input.class");`[cite: 486].
  * **File Output:** `var out = new FileOutputStream("output.bin");`[cite: 498].
      * The `FileOutputStream` constructor can take a second `boolean` argument: `false` to **overwrite** (default) or `true` to **append** to the file[cite: 509, 510, 514, 516].

#### 2.3. Stream Transformers for Interpretation

To interpret the raw bytes as meaningful data (text or binary), you chain the raw streams with specialized **decorator** streams[cite: 387, 791].

| Data Type | Class Used for Reading | Class Used for Writing | Key Methods |
| :--- | :--- | :--- | :--- |
| **Text** | **`Scanner`** (applied to an `InputStream`)[cite: 523, 526]. | **`PrintWriter`** (applied to an `OutputStream`)[cite: 557, 558]. | `scin.nextLine()`, `scin.nextInt()`[cite: 544]; `pout.println(msg)`[cite: 572]. |
| **Binary Data** | **`DataInputStream`**[cite: 618]. | **`DataOutputStream`**[cite: 648]. | `readInt()`, `readDouble()`, `readUTF()`[cite: 636, 637, 638]; `writeInt()`, `writeDouble()`[cite: 670]. |
| **Efficiency/Feature** | **`BufferedInputStream`**[cite: 698]. | **`BufferedOutputStream`** | Reads/writes blocks of data for better performance[cite: 699, 701]. |
| **Feature** | **`PushbackInputStream`**[cite: 720]. | N/A | Allows **speculative reads** by reading a byte and potentially pushing it back into the stream (`unread`)[cite: 713, 724]. |

#### 2.4. Exception Handling

All I/O operations are highly prone to exceptions (e.g., file not found, permission denied, unexpected end of stream). Therefore, Java I/O code **must be wrapped in `try` blocks** to handle exceptions[cite: 606, 607, 687].

-----

### 3\. Illustrative Java Code Examples üíª

#### Example 1: Stream Chaining for Text Copying

This example shows how to chain `FileInputStream` and `PrintWriter` to copy a text file line by line, demonstrating the interpretation of raw bytes as text[cite: 591, 592]. Note that in real Java code, you would use a `try-with-resources` block to automatically handle the `close()` operations.

```java
import java.io.*;
import java.util.Scanner;

public class TextFileCopy {
    public static void main(String[] args) {
        // I/O operations must handle exceptions, usually IOException
        try {
            // 1. Connect raw byte streams to files
            var fin = new FileInputStream("input.txt"); 
            var fout = new FileOutputStream("output.txt"); // Overwrites by default

            // 2. Wrap raw streams with text interpretation streams
            var in = new Scanner(fin);           // Scanner reads the text
            var out = new PrintWriter(fout);     // PrintWriter writes the text

            // 3. Process the data
            System.out.println("Copying file...");
            while (in.hasNextLine()) { // Check if there's another line
                String line = in.nextLine();
                out.println(line); // Writes the line and a newline character
            }

            // Must close streams to release resources (manual close is dangerous, use try-with-resources)
            in.close();
            out.close(); 
            System.out.println("Copying complete.");

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
        }
    }
}
```

#### Example 2: Stream Chaining for Binary Data Writing

This example demonstrates chaining a raw `FileOutputStream` with a `DataOutputStream` to write primitive types (integers and doubles) directly as binary data[cite: 648, 651].

```java
import java.io.*;

public class BinaryDataWriter {
    public static void main(String[] args) {
        try (
            // Use try-with-resources to ensure streams are closed automatically
            var fout = new FileOutputStream("data.bin");
            var dout = new DataOutputStream(fout);
        ) {
            System.out.println("Writing binary data...");
            
            // Writing primitive types directly
            dout.writeInt(12345);
            dout.writeDouble(3.14159);
            dout.writeUTF("Java Binary Data"); // Writes String using UTF-8 encoding

            // flush is automatically called on closing/try-with-resources completion
            System.out.println("Binary data written to data.bin");

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
        }
    }
}
```

