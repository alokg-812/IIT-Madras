## Week 9

### Layman's Terms Explanation

Imagine you order a meal and you're waiting for the dessert. The waiter gives you a **box** (the `Optional` object).

1.  **The Box Has a Dessert:** The value is **present**. You can open the box and enjoy the dessert (`T`).
2.  **The Box is Empty:** The value is **absent**. Instead of getting food poisoning by accidentally biting into empty air (a `NullPointerException`), you immediately know the dessert is missing.

The key benefit is that because you got a box, you are **forced** to check what's inside before trying to eat. You can decide:

  * **If it's empty,** I'll have a piece of cake instead (`orElse`).
  * **If it's empty,** I'll call the chef and ask them to make a new one (`orElseGet`).
  * **If it's empty,** I'll throw a fit and demand an explanation (`orElseThrow`).

It's a way to clearly communicate "This result *might* be empty, so handle the 'empty' case now."

### 2\. Technical Explanation ‚öôÔ∏è

The core concept covered is the **`Optional<T>` object** in Java, primarily in the context of **Streams** and handling potentially missing results.

#### 2.1. Dealing with Empty Streams

Methods like `max()` and `min()` on a Java Stream return an `Optional<T>` because if the stream is **empty** (or if no elements satisfy a filter), the maximum or minimum value is **undefined**.

  * **Problem:** The return value could be `T` (e.g., `Double`) or `null`. A simple `T` return type would mean returning `null` when no value is found, which leads to `NullPointerException` later.
  * **Solution:** By returning **`Optional<T>`**, the result clearly signals that the value *might* not be there.

**Example from slides:**

```java
Optional<Double> maxrand =
    Stream.generate(Math::random) // Start generating random doubles
          .limit(100)           // Take 100 of them
          .filter(n -> n < 0.001) // Keep only very small numbers
          .max(Double::compareTo); // Find the largest one
// maxrand is Optional<Double> because the filter might result in an empty stream.
```

#### 2.2. Handling Missing Optional Values

The `Optional` class provides several methods to safely extract the value or provide an alternative:

| Method | Description | Code Example |
| :--- | :--- | :--- |
| **`orElse(T other)`** | Returns the contained value if present; otherwise, returns the **default value** provided. | `Double fixrand = maxrand.orElse(-1.0);` |
| **`orElseGet(Supplier<? extends T> supplier)`** | Returns the value if present; otherwise, returns the value **generated by the supplied function**. | `Double fixrand = maxrand.orElseGet(() -> someFunctionToGenerateDouble());` |
| **`orElseThrow(Supplier<? extends X> exceptionSupplier)`** | Returns the value if present; otherwise, **throws the exception** generated by the supplied function. | `Double fixrand = maxrand.orElseThrow(IllegalStateException::new);` |
| **`ifPresent(Consumer<? super T> action)`** | If a value is present, executes the given action on the value. If not present, **nothing happens**. | `maxrand.ifPresent(v -> results.add(v));` |
| **`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`** | If a value is present, performs the action; otherwise, performs the **`emptyAction`**. | `maxrand.ifPresentOrElse(v -> results.add(v), () -> System.out.println("No max"));` |

#### 2.3. Creating an Optional Value

You can manually create `Optional` objects:

  * **`Optional.of(v)`:** Creates an `Optional` containing the non-null value `v`. (Throws `NullPointerException` if `v` is null).
  * **`Optional.empty()`:** Creates an empty `Optional`.
  * **`Optional.ofNullable(v)`:** Creates an `Optional` containing `v` if it is non-null, or an empty `Optional` if `v` is `null`. **(Highly useful when dealing with old code that returns `T` or `null`)**.

**Example using `ofNullable`:**

```java
public static Optional<Double> inverse(Double x) {
    // If x is 0, (1/x) would lead to an error or NaN.
    // Returning Optional.ofNullable(1/x) would typically be used 
    // for functions that return null, but here it's shown conceptually.
    // A better implementation for inverse:
    if (x == 0) {
        return Optional.empty();
    }
    return Optional.of(1.0 / x);
}
```

#### 2.4. Passing and Transforming Optional Values

  * **`map(Function<? super T, ? extends U> mapper)`:** If the `Optional` is present, it applies the function (`mapper`) to the value and wraps the result in a new `Optional<U>`. If the `Optional` is empty, it returns an empty `Optional<U>`.

```java
// If maxrand is present, it gets squared and wrapped in maxrandsqr.
Optional<Double> maxrandsqr = maxrand.map(v -> v * v); 
```
  * **`or(Supplier<? extends Optional<? extends T>> supplier)`:** If a value is present, it returns that `Optional`. If it is empty, it returns the `Optional` generated by the supplied `supplier`.

```java
// If maxrand is empty, this returns Optional.of(-1.0).
Optional<Double> fixrand = maxrand.or(() -> Optional.of(-1.0));
```

#### 2.5. Composing Functions with `flatMap` ‚õìÔ∏è

When a function takes a value `T` and returns an **`Optional<U>`**, and you want to chain it with an existing `Optional<T>`, you must use **`flatMap`** to avoid nested `Optional` types (e.g., `Optional<Optional<U>>`).

  * **`flatMap(Function<? super T, ? extends Optional<? extends U>> mapper)`:** If the `Optional` is present, it applies the function (`mapper`) which *already* returns an `Optional<U>`. It returns this resulting `Optional<U>`. If the initial `Optional` is empty, it returns an empty `Optional<U>`.

**Example:** Chaining a safe `inverse` function and a safe `squareRoot` function.

```java
public static Optional<Double> inverse(Double x) {
    return (x == 0) ? Optional.empty() : Optional.of(1.0 / x);
}

public static Optional<Double> squareRoot(Double x) {
    return (x < 0) ? Optional.empty() : Optional.of(Math.sqrt(x));
}

// Chain the operations: 
// 1. Get inverse of x (returns Optional<Double>)
// 2. If present, flatMap applies squareRoot to the result
// The final result is Optional<Double>
Optional<Double> result = inverse(x).flatMap(MyClass::squareRoot);
```

#### 2.6. Turning an Optional into a Stream üåä

`Optional<T>` can be converted into a `Stream` containing either **zero** elements (if empty) or **one** element (if present) using `Optional::stream`. This is useful when processing a stream of inputs where a lookup operation might fail.

```java
// Assume Users::lookup returns Optional<User>
Stream<String> ids = Stream.of("user1", "user2", "missingUser");

Stream<User> users = ids.map(Users::lookup) // Stream<Optional<User>>
                        .flatMap(Optional::stream); // Flatten to Stream<User> (dropping empty Optionals)
```

### 3\. Illustrative Java Code Examples üíª

Here is a consolidated example demonstrating the key concepts:

```java
import java.util.Optional;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;

public class OptionalDemo {

    // Helper function that might return a User or null (old style)
    public static String oldLookup(String id) {
        if (id.equals("admin")) {
            return "Admin User Data"; // Present
        }
        return null; // Missing
    }

    public static void main(String[] args) {
        Random rand = new Random();
        
        // --- 1. Creating an Optional and Dealing with Nulls ---
        System.out.println("--- 1. Creating and Handling Nulls ---");
        
        // Use ofNullable to safely handle a potential null return
        Optional<String> maybeUser = Optional.ofNullable(oldLookup("guest"));
        
        // Handling the missing value with orElse
        String userData = maybeUser.orElse("Default Guest");
        System.out.println("User Data (orElse): " + userData); // Output: Default Guest

        // Handling the present value with ifPresent
        Optional<String> adminUser = Optional.ofNullable(oldLookup("admin"));
        adminUser.ifPresent(data -> System.out.println("Admin Present: " + data)); 
        
        // --- 2. Transforming Optional Values (map) ---
        System.out.println("\n--- 2. Transforming (map) ---");
        
        // Start with a present value
        Optional<Integer> number = Optional.of(10);
        
        // Map: Double the value if present (result is Optional<Integer>(20))
        Optional<Integer> doubled = number.map(n -> n * 2);
        System.out.println("Doubled Value: " + doubled.orElse(0)); // Output: 20

        // Map on an empty Optional (result is still empty)
        Optional<Integer> empty = Optional.empty();
        Optional<Integer> mappedEmpty = empty.map(n -> n * 2);
        System.out.println("Mapped Empty Value: " + mappedEmpty.orElse(0)); // Output: 0
        
        // --- 3. Chaining with flatMap (Concept from slide 21) ---
        System.out.println("\n--- 3. Chaining with flatMap ---");
        
        // Suppose we have an Optional that may or may not be the inverse of a number
        Optional<Double> result = inverse(2.0)
            .flatMap(OptionalDemo::squareRoot); // Applies safe squareRoot to the result of safe inverse
            
        System.out.println("Inverse then SquareRoot of 2.0: " + result.orElse(Double.NaN)); // Output: 0.707...

        Optional<Double> zeroResult = inverse(0.0)
            .flatMap(OptionalDemo::squareRoot);
            
        System.out.println("Inverse then SquareRoot of 0.0: " + zeroResult.orElse(Double.NaN)); // Output: NaN
    }
    
    // Example: Function returning Optional<Double>
    public static Optional<Double> inverse(Double x) {
        return (x == 0) ? Optional.empty() : Optional.of(1.0 / x);
    }

    // Example: Function returning Optional<Double>
    public static Optional<Double> squareRoot(Double x) {
        return (x < 0) ? Optional.empty() : Optional.of(Math.sqrt(x));
    }
}
```